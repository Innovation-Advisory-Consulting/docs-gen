import os
import argparse
from pathlib import Path
import subprocess
from datetime import datetime
import json
import requests

# -----------------------------
# Helpers
# -----------------------------
def read_text(path: Path) -> str:
    return path.read_text(encoding="utf-8", errors="ignore")

def write_text(path: Path, content: str) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content, encoding="utf-8")

def git(cmd):
    try:
        return subprocess.check_output(cmd, stderr=subprocess.DEVNULL).decode("utf-8").strip()
    except Exception:
        return ""

def safe_repo_tree(max_lines: int = 500) -> str:
    out = git(["git", "ls-files"])
    files = out.splitlines() if out else []
    return "\n".join(files[:max_lines])

def pick_key_files() -> list[Path]:
    candidates = [
        Path("README.md"),
        Path("package.json"),
        Path("pyproject.toml"),
        Path("requirements.txt"),
        Path("Dockerfile"),
        Path("docker-compose.yml"),
        Path(".github/workflows"),
    ]
    picked = []
    for c in candidates:
        if c.is_file():
            picked.append(c)
        elif c.is_dir():
            for wf in sorted(c.glob("*.yml"))[:3]:
                picked.append(wf)
    return picked

def build_context(max_chars: int) -> str:
    parts = ["## REPO TREE\n" + safe_repo_tree()]
    for p in pick_key_files():
        try:
            parts.append(f"\n## FILE: {p}\n{read_text(p)[:20000]}")
        except Exception:
            pass
    return "\n".join(parts)[:max_chars]

# -----------------------------
# Azure OpenAI
# -----------------------------
def azure_chat(system: str, user: str) -> str:
    endpoint = os.environ["AZURE_OPENAI_ENDPOINT"].rstrip("/")
    api_key = os.environ["AZURE_OPENAI_API_KEY"]
    deployment = os.environ["AZURE_OPENAI_DEPLOYMENT"]
    api_version = os.environ.get("AZURE_OPENAI_API_VERSION", "2024-02-15-preview")

    url = f"{endpoint}/openai/deployments/{deployment}/chat/completions?api-version={api_version}"
    headers = {
        "Content-Type": "application/json",
        "api-key": api_key,
    }

    payload = {
        "messages": [
            {"role": "system", "content": system},
            {"role": "user", "content": user},
        ],
        "temperature": 0.2,
    }

    r = requests.post(url, headers=headers, json=payload, timeout=120)
    r.raise_for_status()
    return r.json()["choices"][0]["message"]["content"]

# -----------------------------
# Generation
# -----------------------------
DOCS = {
    "solution": ("solution-overview.md", "SolutionOverview.md"),
    "architecture": ("architecture.md", "Architecture.md"),
    "developer": ("developer.md", "Developer.md"),
    "processes": ("processes.md", "BusinessProcesses.md"),
    "customer": ("customer.md", "Customer.md"),
}

SYSTEM_PROMPT = """You are a documentation generator.
Rules:
- Use only provided repository context
- Do not invent architecture or APIs
- Mark missing info as TODO
"""

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--output-dir", default="docs/generated")
    parser.add_argument("--doc-set", default="architecture,developer,processes,customer")
    args = parser.parse_args()

    mode = os.environ.get("DOCGEN_MODE", "ai")
    context = build_context(int(os.environ.get("MAX_CONTEXT_CHARS", "120000")))

    templates_dir = Path(__file__).resolve().parents[1] / "templates"
    out_dir = Path(args.output_dir)

    repo = os.environ.get("GITHUB_REPOSITORY", "unknown")
    sha = os.environ.get("GITHUB_SHA", "unknown")
    now = datetime.utcnow().isoformat()

    header = f"""<!--
Generated by docs-gen
Repo: {repo}
Commit: {sha}
Generated: {now}
-->
"""

    index = ["# Generated Documentation", ""]

    for key in args.doc_set.split(","):
        key = key.strip()
        if key not in DOCS:
            continue

        tpl_name, out_name = DOCS[key]
        tpl = read_text(templates_dir / tpl_name)

        if mode == "static":
            content = tpl
        else:
            prompt = f"{tpl}\n\nRepository context:\n{context}"
            content = azure_chat(SYSTEM_PROMPT, prompt)

        write_text(out_dir / out_name, header + content)
        index.append(f"- [{out_name}]({out_name})")

    write_text(out_dir / "README.md", "\n".join(index))

if __name__ == "__main__":
    main()
